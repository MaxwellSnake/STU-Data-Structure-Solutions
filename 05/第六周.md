1.若按教科书图 3.1(b)所示铁道进行车厢调度( 两侧均为单行道 )。则请回答： (a)如果车厢序列为 123, 则可能得到的出站车厢序列为怎样的? (b)如果进站车厢序列为 123456, 则是否能得到 435612 和 135426 的出站序列。 ( 即写出″进栈″或″出栈″的序列 )

2.按照四则运算加减乘除和幂运算(↑)优先关系的惯例，并仿照书上的格式，画出对下列算术表达式求值时操作数栈和运算符栈的变化过程： $$A-B \times {C \over D}+E↑F$$

3.设两个栈共享向量空间 V(1:m)，它们的栈底分别设在向量的两端，且进栈的每个元素只占一个分量。试写出这两个栈的公用栈操作算法 PUSH(i,X), POPI(i) 和 TOPI(i),其中 i 为 0 或 1 用以指示栈号。并讨论按过程或函数设计这些操作算法各有什么优缺点。

4.说明栈和一维数组的异同点。

5.以 flag 为标志, 写循环队列插入删除算法, flag=0 表示队空; flag=1 表示队不空。

### 第一题

(1) 123 或 231 或 321 或 213 或 132 

(2) 可以得到 135426 的出站序列，但不能得到 435612 的出站序列。因为 4356 出站说明 12 已经在栈中，1 不可能先于 2 出栈。

### 第二题

> 相关答案集 第3.7 题，请复制下来做成表格形式



### 第四题





### 第五题

> 我粗略地看了一下，应该没问题吧？——max

```C
#define MaxQSize 7
typedef int ElemType;
typedef struct{
	ElemType *base;
	int front;
	int rear;
	Status flag; 
}Queue;

Status InitQueue(Queue &q) {
	q.base=new ElemType[MaxQSize];
	if(!q.base) 
		return FALSE;
	q.front=0; 
	q.rear=0; 
	q.flag=0;
	return OK;
} 

Status EnQueue(Queue &q, ElemType e){
	if(q.front==q.rear && q.flag) 
		return FALSE;
	else{
		q.base[q.rear]=e;
		q.rear=(q.rear+1)%MaxQSize;
		if(q.rear==q.front)
			q.flag=1;
	} 
	return OK;
}

Status DeQueue(Queue &q,ElemType &e){
	if(q.front==q.rear && !q.flag)
		return FALSE; 
	else{
		e=q.base[q.front];
		q.front=(q.front+1)%MaxQSize;
		q.flag=0;
	} 
	return OK;
}
```

